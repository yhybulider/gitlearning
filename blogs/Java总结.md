# Java学习总结

今天就总结理清一下关于面向对象和面向过程的程序设计的一些不同特点。

[TOC]



## 概论

* 现在接触的Java是面向对象的，我现在不看书，光靠回忆去想这个特性的解释性语言，只能想到看书时很深刻的一句话，面向对象就是一个更加具体描述一个事件的一种设计方法，就像在公司里面吃饭，面向对象的话就可以按照你自己的想法去决定你想吃什么，喝什么，吃多久，坐在哪里，这些都是可以实例具体差异化展开。
* 关于面向对象的程序设计三个特点：封装性、继承性、多态性。
首先封装性是把对象属性、行为看成一个密不可分的整体封装在独立单位中，一种信息隐蔽的特性。
其次是继承性：父类与子类的表达与描述就是一种继承性，拥有反映事物一般特性的类，在其基础上派生出反映特殊事物的类。（类是由属性和方法组成）。
最后是多态性，包括方法重载和对象多态。子类与父类可以相互转换，根据其使用的子类不同完成的功能也不同。
* 类的构造方法：与类同名的方法。
* java的四块内存空间
  * 堆内存空间：保存所有对象的名称（堆内存空间的地址）
  * 栈内存空间：保存每个对象的具体属性内容
  * 全局数据区：保留static类型的属性
  * 全局代码区：保存所有的方法定义
* 全局和局部变量是相对而言的。
* 访问属性，建议加上this。



# #面向对象的基本概念

## 数组

* 数组固定长度，无法改变

* 数组插入删除比较麻烦，需要移动其它元素。 随机读取比较快速，高效

* 定义：（多维的话类型，将[]变为[][]）

  * 数据类型 名字[] = new 数据类型[长度]——动态初始化 
  * 数据类型 名字[] = new 数据类型[]{直接具体的数值}——动态初始化
  * 不建议使用多维数组

* 例子：

  * 数组倒置（reverse）——1定义两个数组，一个是原数组，另一个空数组，将空数组的最后一个元素，对应原数组的第一个，以此类推。这是会产生垃圾，这个空数组会变成垃圾2可以通过数组长度/2次循环。实现首尾的交换

    ![image.png](https://i.loli.net/2019/12/15/bPyoWpDZBsvdGVO.png)

* 数组复制：System.arraycopy(原数组，复制开始索引，目标数组，目标开始索引，长度)     数组排序：java.util.Arrays.sort(数组);

* 对象数组：数组是引用类型 ，就是除了数据类型改变了，这里是类对象，之前是数据类型，其它没有任何区别

  * 类名称 对象数组名称=new 类名称[长度]——静态初始化。动态初始化和普通的没区别。
  
* Arraylist与数组

## String类

* ![image-20191211094606003.png](https://i.loli.net/2019/12/15/op3zfgj2Us6hlBR.png)
* ==与equals():前者是用于所有的引用数据类型的比较，比较的是地址的数值内容。后者是比较字符串的内容
* String的两种赋值方法
  * 直接赋值 String str = "随便"，只要内容相同就不会产生新的堆内存空间。
  * 构造方法赋值 用了new：String str1 = new String("随便")——这个会产生垃圾空间，new会开辟新的堆内存空间。
* 所以构造方法new不会主动入池，需要在后面加上**.intern（）**才可以。所以不主动入池，上面的str=str1的结果是false
* String频繁改变就会产生垃圾空间，一般都是用StringBuffer或者StringBuilder来代替
* string——char charAt（int index）会报错`IndexOutOfBoundsException` - if the `index` argument is negative or not less than the length of this string.
* public int indexOf(String str)由前向后查找指定字符串的位置，如果找到了则返回第一个字母的位置索引。如果找不到就返回-1。
* str.split()字符串拆分 toLowerCase()-转小写 toUpperCase()-转大写。
* 字符串的length（）与数组的length要注意，一个没有（）
* 特意回忆下，八种数据类型：boolean byte double float int short char long

## this关键字

* 总的来说叫，调用本类属性，调用本类方法，表示当前对象。
  1. 本类属性——用this.title=xx,前提是前面的形参有这个title。传统的是可以直接title=xx，但是为了不必要的麻烦（类中的属性可能会和参数重名）
  2. 调用本类方法：普通的就直接this.方法（），构造的话可以this（）就可以。有参数就变为this(参数)——这个方法在解决构造方法成千上百行时候会显得效率奇高。
  3. 表示当前对象：返回当前的值。

## 引用传递

* 同一块堆内存空间可以被不同的栈内存所指向，不同栈内存可以对同一堆内存进行内容修改。

## static关键字

* 一个人类的主要组成就是属性和方法（构造方法和普通方法），如果一个类中的某个属性想被所有对象访问，就变成公共的，可以在属性前面加多一个static。
* Java中的变量分为成员变量和局部变量；局部变量还分为三种：形参、方法内的局部变量、代码块内的局部变量（作用范围看名字就可以明白，如代码块内的，代码块结束后就开始失效消亡）。成员变量：类体内定义的变量，包括了非静态变量又称实例变量，和静态变量又称类变量。
* static字面意思是静态；但是在Java程序中，它是一个标志，作用是将**实例成员**变为类成员。而且只能修饰在类里定义的成员部分，包括成员变量、方法，内部类、初始化块。不用static去修饰类里的这些成员，它们就属于该类的实例。
  </br>eg：static int num2 = 20;(这是一个类变量)
  </br>eg: int num1 = 238;(实例变量)

* static修饰的成员属于类，类变量会随着类初始化得到初始化；而没有static修饰的成员变量则属于实例，实例变量随着对象的初始化而初始化。因为在初始化之前一个对象之前，肯定得先初始化该对象所属的类，所以static修饰的时机肯定较实例变量早。

* **static方法**一般称作静态方法，不依赖任何对象就可以进行访问，因此对于静态方法来说，没有this的。

## 代码块

- 使用{}——可以分为普通代码块（写在方法里）、构造块（写在类里面）、静态块（用static定义的代码块）-作用可以为static属性初始化和同步代码块（等待多线程时候）

- ```java
  //卸载方法里
  public static void main(String args[]){
      {
          System.out.println();
      }
  }
  //代码写在类里。构造块
  class test{
      {
          System.out.println();
      }
  }
  //静态块,运行时候会优先调用。而且之调用一次，若主函数里面用了两次new test ,下面的2也只是第一次输出
  class test{
      static{
      System.out.println("2");
  	}
  }
  ```

  

## 内部类

- 简单讲就是类中再定义类。**可以在类内的任意位置（代码块或者是普通方法中）**下面的例子可以看出内部类就是可以帮助主函数轻松访问其他类的私有属性。但是其破坏了类的结构性。开发中也不优先考虑。而且外部类也可以轻松访问内部类的私有，也是直接new实例化内部类

- ```java
  class outer{//外部类
      private String msg = "waibulei";
      class inner{ //内部类
          public void print(){
              System.out.println(msg);
       	   }
          }
      public void fun(){
              new inner().print();//实例化内部类对象，调用print方法
      }
  }
  public class test{
      public static void main(String args[]){
          outer out = new outer();//实例化外部类对象
          out.fun();//调用外部类方法
      }
  }
  //这个代码是一层套一层
  ```

- 在主函数中实例化内部类的格式——outer.inner in = new outer.inner();

- 若在inner前面加上private，则该内部类只能服务于外部类。

## 链表

- 链表逻辑简单、比较实用，几乎被所有程序设计语言支持。是一种根据元素节点逻辑关系排列起来的数据结构。

- ![image.png](https://i.loli.net/2019/12/15/DznMocCuhvyFl28.png)

- 链表也分单向和双向（一个数据域，两个指针域-指向后继，指向前驱，在最后指向表头结点），还有循环链表（和单链表基本相同，但是最后一个结点的指针域不空，指向表头结点）。

- node类有两个属性：（数据）data和（下一节点）next（指明自己有什么，还提醒下一个在哪，看起来是非常友好的结构。）——单向的

- 动态的对象数组，优势在与没有长度限制。

- ```java
  
  ```

  

